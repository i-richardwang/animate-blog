---
title: 探索性数据分析
description: 机器学习实战系列：第二篇聚焦探索性数据分析（EDA），运用可视化与统计方法，检查变量分布与特征关联
releaseDate: 2023-10-29
author:
  name: Richard Wang
  url: https://imrichard.com
---

import {
  Tabs,
  TabsList,
  TabsTrigger,
  TabsContents,
  TabsContent,
} from '@/components/radix/tabs';

在前一篇文章[《员工流失预测项目实战（一）：建模目标与数据质量》](/docs/data-science/analysis/employee-attrition-data-quality)中,我们明确了项目的业务目标并完成了关键的数据质量评估，为后续的建模工作奠定了基础。高质量的数据虽是起点，但要构建有效的预测模型，我们还需深入理解数据本身蕴含的信息。

本文将聚焦于**探索性数据分析（Exploratory Data Analysis, EDA）**。EDA 是连接数据准备和模型构建的关键桥梁，其**核心目标是为后续的特征工程和模型选择提供坚实的依据与方向**。我们将通过可视化和统计摘要等手段，系统性地检查变量分布特性、识别特征与目标变量（`Attrition`）间的潜在关联，并发现可能影响模型性能的数据模式（如类别不平衡、特征间的交互作用等）。

这些发现将直接指导我们如何更有效地**选择、转换和构造特征**，并帮助我们预判建模过程中可能遇到的挑战，从而选择更合适的**模型算法和评估策略**。

我们将按以下顺序进行分析：

1. 目标变量（`Attrition`）的分布情况。
2. 特征与目标变量之间的相关性分析。
3. 连续特征在不同流失状态下的分布差异。
4. 离散特征在不同流失状态下的分布差异及流失率。
5. 组合特征对员工流失的影响。

## 目标变量分布

在深入分析特征之前，我们首先需要了解预测目标 `Attrition`（是否流失）字段的分布情况。这将帮助我们把握问题的基线，特别是判断是否存在**类别不平衡**问题，这对选择合适的模型和评估策略至关重要。

我们通常使用柱状图和饼状图来直观展示目标变量的分布。

<Tabs defaultValue="plotly">
  <TabsList>
    <TabsTrigger value="plotly">Plotly 实现</TabsTrigger>
    <TabsTrigger value="matplotlib">Matplotlib 实现</TabsTrigger>
  </TabsList>
  <TabsContents>
    <TabsContent value="plotly">
      ![Plotly 绘制的 Attrition 标签分布柱状图与饼图，显示类别不平衡。](/data-science/analysis/eda_label_distribution_plotly.webp)

      ```python
      import plotly.graph_objects as go
      from plotly.subplots import make_subplots

      # 计算离职和在职的数量
      attrition_counts = train_df['Attrition'].value_counts()
      labels = ['在职', '离职']
      values = [attrition_counts[0], attrition_counts[1]]

      # 定义配色
      colors = ['#CDBBA7', '#C02B34']

      fig = make_subplots(rows=1, cols=2, subplot_titles=('离职标签人数统计', '离职标签分布统计'),
                          specs=[[{"type": "bar"}, {"type": "pie"}]])

      # 添加柱状图
      fig.add_trace(
          go.Bar(x=labels, y=values, marker_color=colors, opacity=.8,
                 text=values, textposition='outside', width=0.5, showlegend=False),
          row=1, col=1
      )

      # 添加饼状图
      fig.add_trace(
          go.Pie(labels=labels, values=values, marker_colors=colors, opacity=.8, name='占比', hole=0.5, showlegend=True),
          row=1, col=2
      )

      # 更新布局
      fig.update_layout(
          title_text='标签统计',
          plot_bgcolor='#F4F2F0', paper_bgcolor='#F4F2F0',  # 设置画布和图表的背景颜色
          width=1000, height=500,
      )

      # 显示图表
      fig.show()
      ```
    </TabsContent>
    <TabsContent value="matplotlib">
      ![Matplotlib 绘制的 Attrition 标签分布柱状图与饼图，显示类别不平衡。](/data-science/analysis/eda_label_distribution_matplotlib.webp)

      ```python
      import pandas as pd
      import matplotlib.pyplot as plt
      import seaborn as sns

      # 加载数据集
      train_df = pd.read_csv('train.csv')

      # 设置背景颜色
      plt.rcParams['figure.facecolor'] = '#F4F2F0'
      plt.rcParams['axes.facecolor'] = '#F4F2F0'

      # 计算 Attrition 的值分布
      attrition_counts = train_df['Attrition'].value_counts()
      attrition_labels = ['No', 'Yes']

      # 设置颜色
      colors = ['#CDBBA7', '#C02B34']
      colors_alpha = [plt.cm.colors.to_rgba(c, 0.8) for c in colors]

      # 创建画布
      fig, axes = plt.subplots(1, 2, figsize=(12, 5))

      # 绘制柱状图
      sns.barplot(x=attrition_labels, y=attrition_counts.values, palette=colors, ax=axes[0], alpha=0.8)
      axes[0].set_title('Attrition Count')
      axes[0].set_xlabel('Attrition')
      axes[0].set_ylabel('Count')

      # 绘制饼状图
      axes[1].pie(attrition_counts, labels=attrition_labels, autopct='%1.1f%%', colors=colors_alpha, startangle=90)
      axes[1].set_title('Attrition Distribution')

      # 显示图表
      plt.tight_layout()
      plt.show()
      ```
    </TabsContent>

  </TabsContents>
</Tabs>

**关键发现：**

- **明显的类别不平衡：** 数据集呈现典型的不平衡分布，离职员工（标签为 1）占比远低于在职员工（标签为 0）。
- **对建模的影响：** 这种不平衡会显著影响模型训练效果。若不妥善处理，模型可能过度倾向预测多数类（在职），导致对少数类（离职）的预测准确度较低。后续建模时需考虑采用**过采样、欠采样、代价敏感学习**等平衡方法，或使用**F1-score、ROC-AUC**等对不平衡数据不敏感的评估指标。

## 特征与标签的相关性

首先，我们计算各特征与目标变量 `Attrition` 的**相关性系数**（如皮尔逊相关系数），这能快速揭示哪些特征可能与员工流失存在**线性关联**。

解读相关性时需注意：

- 关注**绝对值**大小：无论正相关还是负相关，绝对值越大，表示线性关联越强，潜在预测价值越高。
- **正相关**：特征值越高，流失可能性越大。
- **负相关**：特征值越高，流失可能性越小（即留存可能性越大）。
- **局限性**：相关性仅衡量线性关系，无法捕捉非线性模式或复杂的交互效应。

为了计算相关性，需要先将类别型特征进行数值化处理（如此处使用 One-Hot 编码）。

<Tabs defaultValue="plotly">
  <TabsList>
    <TabsTrigger value="plotly">Plotly 实现</TabsTrigger>
    <TabsTrigger value="matplotlib">Matplotlib 实现</TabsTrigger>
  </TabsList>
  <TabsContents>
    <TabsContent value="plotly">
      ![Plotly 绘制的各特征与 Attrition 的相关性系数条形图](/data-science/analysis/eda_correlation_coefficient_plotly-scaled.webp)

      ```python
      # 将分类变量转换为数值变量
      train_df_encoded = pd.get_dummies(train_df)

      # 计算相关性矩阵并移除 'Attrition' 自己
      corr_with_label = train_df_encoded.corr()['Attrition'].drop('Attrition').sort_values(ascending=False)

      # 创建条形图
      fig = go.Figure()

      fig.add_trace(go.Bar(
          x=corr_with_label.index,
          y=corr_with_label.values,
          marker_color=['#C02B34' if x > 0 else '#CDBBA7' for x in corr_with_label.values]
      ))

      # 更新布局
      fig.update_layout(
          title='Correlation of Features with Attrition',
          xaxis_title='Features',
          yaxis_title='Correlation Coefficient',
          plot_bgcolor='#F4F2F0',
          paper_bgcolor='#F4F2F0',
          height=800,
          width=1500
      )

      # 显示图表
      fig.show()
      ```
    </TabsContent>
    <TabsContent value="matplotlib">
      ![Matplotlib 绘制的各特征与 Attrition 的相关性系数条形图](/data-science/analysis/eda_correlation_coefficient_matplotlib-scaled.webp)

      ```python
      # 将分类变量转换为数值变量
      train_df_encoded = pd.get_dummies(train_df)

      # 设置背景颜色
      plt.rcParams['figure.facecolor'] = '#F4F2F0'
      plt.rcParams['axes.facecolor'] = '#F4F2F0'

      # 计算相关性矩阵并移除 'Attrition' 自己
      corr_with_label = train_df_encoded.corr()['Attrition'].drop('Attrition').sort_values(ascending=False)

      # 创建画布
      plt.figure(figsize=(18, 6))

      # 绘制相关性条形图
      corr_with_label.plot(kind='bar', color=['#C02B34' if x > 0 else '#CDBBA7' for x in corr_with_label])

      # 设置标题和标签
      plt.title('Correlation of Features with Attrition')
      plt.xlabel('Features')
      plt.ylabel('Correlation Coefficient')

      # 显示图表
      plt.show()
      ```
    </TabsContent>

  </TabsContents>
</Tabs>

其中强相关的特征是后续建模和特征工程中需要重点关注的对象。同时，相关性较低的特征不一定无用，可能存在非线性关系或与其他特征组合时才能发挥作用，需要在后续分析中进一步验证。

## 连续特征分布差异

对于数值型的连续特征（如 `Age`, `MonthlyIncome`, `DistanceFromHome` 等），我们需要观察它们在离职（Attrition=1）和在职（Attrition=0）两个群体中的分布是否存在显著差异。直方图和核密度估计（KDE）图是常用的可视化工具。

这里以 `Age`（年龄）特征为例进行分析。

<Tabs defaultValue="plotly">
  <TabsList>
    <TabsTrigger value="plotly">Plotly 实现</TabsTrigger>
    <TabsTrigger value="matplotlib">Matplotlib 实现</TabsTrigger>
  </TabsList>
  <TabsContents>
    <TabsContent value="plotly">
      ![Plotly 绘制的 Age 在不同 Attrition 状态下的直方图与KDE曲线](/data-science/analysis/eda_continuous_feature_distribution_plotly.webp)

      ```python
      import pandas as pd
      import plotly.figure_factory as ff
      import plotly.graph_objects as go

      # 选择一个连续特征进行可视化，比如 'Age'
      feature = 'Age'

      # 按 'Attrition' 分组获取特征数据
      no_attrition = train_df[train_df['Attrition'] == 0][feature].dropna()
      yes_attrition = train_df[train_df['Attrition'] == 1][feature].dropna()

      # 数据分组和标签
      hist_data = [no_attrition, yes_attrition]
      group_labels = ['No', 'Yes']
      colors = ['#CDBBA7', '#C02B34']

      # 使用 create_distplot 创建分布图
      fig = ff.create_distplot(hist_data, group_labels, show_hist=True, show_rug=False, colors=colors)

      # 更新布局
      fig.update_layout(
          title_text=f'Distribution of {feature} by Attrition',
          xaxis_title_text=feature,
          yaxis_title_text='Density',
          plot_bgcolor='#F4F2F0',
          paper_bgcolor='#F4F2F0', width=1000, height=500
      )

      # 显示图表
      fig.show()
      ```
    </TabsContent>
    <TabsContent value="matplotlib">
      ![Matplotlib 绘制的 Age 在不同 Attrition 状态下的直方图与KDE曲线](/data-science/analysis/eda_continuous_feature_distribution_matplotlib.webp)

      ```python
      # 设置背景颜色
      plt.rcParams['figure.facecolor'] = '#F4F2F0'
      plt.rcParams['axes.facecolor'] = '#F4F2F0'

      # 选择一个连续特征进行可视化，比如 'Age'
      feature = 'Age'

      # 设置颜色
      colors = {1: '#C02B34', 0: '#497B7A'}

      # 创建画布
      plt.figure(figsize=(12, 5))

      # 绘制标准化的直方图
      sns.histplot(data=train_df, x=feature, hue='Attrition', element='step', stat='density', common_norm=False,
                   palette=colors, alpha=0.5)

      # 绘制 KDE 曲线
      sns.kdeplot(data=train_df, x=feature, hue='Attrition', palette=colors, common_norm=False)

      # 设置标题和标签
      plt.title(f'Distribution of {feature} by Attrition')
      plt.xlabel(feature)
      plt.ylabel('Density')

      # 显示图表
      plt.show()
      ```
    </TabsContent>

  </TabsContents>
</Tabs>

**关键发现（`Age`）：**

- **年轻员工流失倾向更高：**从分布图可见，离职员工（红色分布）的年龄明显偏向年轻，峰值约在30岁。相比之下，在职员工（米色分布）年龄分布更偏右，峰值在35岁左右，且分布更为广泛。
- **潜在分界点：**在33-35岁区间，两条分布曲线出现交叉。这个年龄段以下的员工离职密度较高，而年龄段以上的员工则倾向于留任。
- **特征工程启发：**这一观察结果揭示年龄是关键预测因子。特征工程阶段可考虑以下方案：
  - 直接使用`Age`特征
  - 根据分界点创建二元特征，如 `Is_Under_34`（是否小于34岁）
  - 采用分箱（Binning）方法，将年龄划分为"青年"、"中年"、"资深"等区间，分析各区间的流失率差异

## 离散特征的分布差异

对于类别型的离散特征（如 `Department`, `Gender`, `MaritalStatus`, `JobRole` 等），我们关心的重点是**不同类别下的流失率是否存在显著差异**。组合使用柱状图和折线图是一种有效的可视化方法。

这里以 `Department`（部门）特征为例进行分析。

<Tabs defaultValue="plotly">
  <TabsList>
    <TabsTrigger value="plotly">Plotly 实现</TabsTrigger>
    <TabsTrigger value="matplotlib">Matplotlib 实现</TabsTrigger>
  </TabsList>
  <TabsContents>
    <TabsContent value="plotly">
      ![Plotly 绘制的按 Department 分组的员工数与流失率](/data-science/analysis/eda_discrete_feature_distribution_plotly.webp)

      ```python
      # 选择一个离散特征，比如 'Department'
      feature = 'Department'

      # 计算每个部门的在职和离职人数
      department_counts = train_df.groupby([feature, 'Attrition']).size().unstack(fill_value=0)
      department_counts['Total'] = department_counts.sum(axis=1)
      department_counts['Attrition Rate'] = department_counts[1] / department_counts['Total']

      # 创建子图
      fig = make_subplots(specs=[[{"secondary_y": True}]])

      # 添加在职和离职的柱状图
      fig.add_trace(
          go.Bar(name='No', x=department_counts.index, y=department_counts[0], marker_color='#CDBBA7'),
          secondary_y=False,
      )

      fig.add_trace(
          go.Bar(name='Yes', x=department_counts.index, y=department_counts[1], marker_color='#C02B34'),
          secondary_y=False,
      )

      # 添加离职率的折线图
      fig.add_trace(
          go.Scatter(name='Attrition Rate', x=department_counts.index, y=department_counts['Attrition Rate'], mode='lines+markers', marker_color='#497B7A', opacity = 0.8),
          secondary_y=True,
      )

      # 更新布局
      fig.update_layout(
          title_text=f'Distribution and Attrition Rate by {feature}',
          yaxis_title='Count',
          yaxis2_title='Attrition Rate',
          plot_bgcolor='#F4F2F0',
          paper_bgcolor='#F4F2F0',
          barmode='group'
      )

      fig.update_yaxes(showgrid=False, secondary_y=False)
      fig.update_yaxes(showgrid=False, secondary_y=False)

      # 显示图表
      fig.show()
      ```
    </TabsContent>
    <TabsContent value="matplotlib">
      ![Matplotlib 绘制的按 Department 分组的员工数与流失率](/data-science/analysis/eda_discrete_feature_distribution_matplotlib.webp)

      ```python
      # 选择一个离散特征，比如 'Department'
      feature = 'Department'

      # 计算每个部门的在职和离职人数
      department_counts = train_df.groupby([feature, 'Attrition']).size().unstack(fill_value=0)
      department_counts['Total'] = department_counts.sum(axis=1)
      department_counts['Attrition Rate'] = department_counts[1] / department_counts['Total']

      # 设置背景颜色
      plt.rcParams['figure.facecolor'] = '#F4F2F0'
      plt.rcParams['axes.facecolor'] = '#F4F2F0'

      # 创建画布和双 y 轴
      fig, ax1 = plt.subplots(figsize=(10, 5))

      # 绘制在职和离职的柱状图
      department_counts[[0, 1]].plot(kind='bar', stacked=False, color=['#CDBBA7', '#C02B34'], ax=ax1)
      ax1.set_xlabel('')
      ax1.set_ylabel('Count')
      ax1.set_title(f'Distribution and Attrition Rate by {feature}')
      ax1.legend(['No', 'Yes'], loc='upper left')

      # 去掉横向网格线
      ax1.grid(False)

      # 调整横坐标标签的字体大小
      ax1.set_xticklabels(ax1.get_xticklabels(), rotation=0, fontsize=10)

      # 创建次 y 轴并绘制离职率折线图
      ax2 = ax1.twinx()
      ax2.plot(department_counts.index, department_counts['Attrition Rate'],
               color='#497B7A', alpha = 0.8, marker='o', linestyle='--', linewidth=2, markersize=5)
      ax2.set_ylabel('Attrition Rate')
      ax2.grid(False)


      # 显示图表
      plt.tight_layout()
      plt.show()
      ```
    </TabsContent>

  </TabsContents>
</Tabs>

**关键发现（`Department`）：**

- **部门间流失率差异：** 各部门的流失率表现出显著差异。数据显示，`Sales`（销售）和 `Human Resources`（人力资源）部门的流失率明显高于 `Research & Development`（研发）部门。
- **人数与比例的综合分析：** 虽然 `R&D` 部门因规模最大而有最多的离职人数，但从流失率来看，`Sales` 部门的情况更为严峻。这种结合绝对数量和相对比例的分析方法提供了更全面的视角。
- **特征工程与业务启示：**`Department` 将作为重要的预测特征，需通过 One-Hot Encoding 或 Target Encoding 进行适当编码。

## 组合特征在不同标签上的分布

员工流失通常由多个因素共同作用导致，而非单一因素所致。因此，探索特征之间的组合如何影响流失情况十分重要，这能帮助我们发现更深层的模式和交互效应。

### 离散特征与连续特征的组合分析

我们通过观察连续特征在不同离散类别下的分布特征，并结合流失状态进行分析。箱线图（Box Plot）和小提琴图（Violin Plot）是展示这类组合关系的理想工具。

让我们以 `MaritalStatus`（婚姻状况）和 `DistanceFromHome`（离家距离）为例进行分析。

<Tabs defaultValue="plotly">
  <TabsList>
    <TabsTrigger value="plotly">Plotly 实现</TabsTrigger>
    <TabsTrigger value="matplotlib">Matplotlib 实现</TabsTrigger>
  </TabsList>
  <TabsContents>
    <TabsContent value="plotly">
      ![Plotly 绘制的 DistanceFromHome 在不同 MaritalStatus 与 Attrition 组合下的箱线图比较。](/data-science/analysis/eda_feature_combination_boxplot_plotly.webp)

      ```python
      import plotly.express as px

      # 选择特征和标签
      feature_categorical = 'MaritalStatus'
      feature_continuous = 'DistanceFromHome'
      target = 'Attrition'

      # 创建箱线图
      fig = px.box(train_df, y=feature_continuous, x=feature_categorical, color=target,
                   points=False, hover_data=train_df.columns,
                   color_discrete_map={0: '#CDBBA7', 1: '#C02B34'})

      # 更新布局
      fig.update_layout(
          title=f'Distribution of {feature_continuous} by {feature_categorical} and {target}',
          xaxis_title=feature_categorical,
          yaxis_title=feature_continuous,
          plot_bgcolor='#F4F2F0',
          paper_bgcolor='#F4F2F0', width=1000, height=500
      )

      # 显示图表
      fig.show()
      ```
    </TabsContent>
    <TabsContent value="matplotlib">
      ![Matplotlib 绘制的 DistanceFromHome 在不同 MaritalStatus 与 Attrition 组合下的箱线图比较。](/data-science/analysis/eda_feature_combination_boxplot_matplotlib.webp)

      ```python
      # 设置背景颜色
      plt.rcParams['figure.facecolor'] = '#F4F2F0'
      plt.rcParams['axes.facecolor'] = '#F4F2F0'

      # 选择特征和标签
      feature_categorical = 'MaritalStatus'
      feature_continuous = 'DistanceFromHome'
      target = 'Attrition'

      # 创建画布
      fig, ax = plt.subplots(figsize=(10, 6))

      # 绘制箱线图
      sns.boxplot(x=feature_categorical, y=feature_continuous, hue=target, data=train_df, palette=['#CDBBA7', '#C02B34'], ax=ax)

      # 设置标题和标签
      ax.set_title(f'Distribution of {feature_continuous} by {feature_categorical} and {target}')
      ax.set_xlabel(feature_categorical)
      ax.set_ylabel(feature_continuous)

      # 显示图表
      plt.tight_layout()
      plt.show()
      ```
    </TabsContent>

  </TabsContents>
</Tabs>

**关键发现 (`MaritalStatus` & `DistanceFromHome`)：**

- **通勤距离影响因婚姻状况而异：**对于 `Single`（单身）和 `Divorced`（离异）的员工群体，离职者的 `DistanceFromHome`（离家距离）分布显著高于在职者。这意味着对于这两类人群，**住得远是与其流失风险增加相关的显著因素**。
- **特征工程启发：** 这个发现非常有价值，它表明简单地独立看待 `MaritalStatus` 或 `DistanceFromHome` 可能不足以捕捉全部信息。为了让模型更好地学习这种**条件依赖关系**，在特征工程阶段可以考虑：
  - **创建组合特征（Combined Features）**来显式地表达这种模式，如 `Single_x_FarFromHome`，一个代表"单身且住得远"的标志。
  - 或者在模型选择上倾向于那些能够**捕捉特征间复杂关系**的模型，例如**决策树、随机森林、梯度提升树**等基于树的模型。这类模型通过节点分裂，天然地能够学习到类似"如果婚姻状况是单身，则离家距离的影响是..."这样的规则。

此外，对于连续变量与离散变量组合的情况，我们也可以绘制每个MaritalStatus类别下，离职与在职员工DistanceFromHome的概率密度曲线（KDE），观察分布形态的差别，得到相同的结论。

![按 MaritalStatus 分别绘制的 DistanceFromHome KDE曲线](/data-science/analysis/eda_feature_combination_kde_plotly.webp)

```python
# 选择特征和标签
feature_categorical = 'MaritalStatus'
feature_continuous = 'DistanceFromHome'
target = 'Attrition'

# 获取不同MaritalStatus的值
marital_statuses = train_df[feature_categorical].unique()

# 创建子图布局
fig = make_subplots(rows=1, cols=3, subplot_titles=marital_statuses, horizontal_spacing=0.1)

# 设置颜色映射
colors = {0: '#CDBBA7', 1: '#C02B34'}

# 为每个MaritalStatus创建KDE分布图
for i, status in enumerate(marital_statuses):
    subset = train_df[train_df[feature_categorical] == status]
    hist_data = [subset[subset[target] == 0][feature_continuous], subset[subset[target] == 1][feature_continuous]]
    group_labels = [0, 1]

    # 使用 create_distplot 创建KDE分布图
    distplot = ff.create_distplot(hist_data, group_labels, show_hist=False, show_rug=False, colors=[colors[0], colors[1]])

    # 添加KDE分布曲线到子图
    for trace in distplot['data']:
        fig.add_trace(trace, row=1, col=i+1)

# 更新布局
fig.update_layout(
    title_text=f'{feature_continuous} KDE Distribution by {feature_categorical} and {target}',
    plot_bgcolor='#F4F2F0',
    paper_bgcolor='#F4F2F0', width=1000, height=500
)

# 显示图表
fig.show()
```

### 连续特征 & 连续特征组合

对于两个连续特征，我们可以使用散点图（Scatter Plot）或二维密度图/等高线图（2D Density/Contour Plot）来观察它们之间的关系，并根据流失状态进行着色或区分。

以 `Age`（年龄）和 `MonthlyIncome`（月收入）为例。

![Plotly 绘制的 Age & MonthlyIncome 与标签的等高线图](/data-science/analysis/eda_feature_combination_contour_plotly.webp)

```python
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# 选择特征和标签
feature_x = 'Age'
feature_y = 'MonthlyIncome'
target = 'Attrition'

# 创建子图布局
fig = make_subplots(rows=1, cols=2, subplot_titles=['Attrition: No', 'Attrition: Yes'], shared_yaxes=True)

# 绘制在职等高线图
no_attrition = train_df[train_df[target] == 0]
fig.add_trace(
    go.Histogram2dContour(
        x=no_attrition[feature_x],
        y=no_attrition[feature_y],
        colorscale='Blues',
        contours=dict(showlines=False),
        showscale=False
    ),
    row=1, col=1
)

# 绘制离职等高线图
yes_attrition = train_df[train_df[target] == 1]
fig.add_trace(
    go.Histogram2dContour(
        x=yes_attrition[feature_x],
        y=yes_attrition[feature_y],
        colorscale='Reds',
        contours=dict(showlines=False),
        showscale=False
    ),
    row=1, col=2
)

# 获取特征的最大和最小值，用于设置相同的坐标轴比例尺
x_range = [train_df[feature_x].min(), train_df[feature_x].max()]
y_range = [-2000, train_df[feature_y].max()]

# 更新布局
fig.update_layout(
    title_text=f'{feature_x} vs {feature_y} Contour Plot by {target}',
    xaxis_title=feature_x,
    yaxis_title=feature_y,
    xaxis=dict(range=x_range),
    yaxis=dict(range=y_range),
    plot_bgcolor='#F4F2F0',
    paper_bgcolor='#F4F2F0', width=800, height=500
)

# 显示图表
fig.show()
```

**关键发现 (Age & MonthlyIncome)：**

- **显著的分布差异：** 在职员工（左图，蓝色）与离职员工（右图，红色）在 Age 和 MonthlyIncome 的联合分布上呈现显著不同。

## 从洞察到特征

这一轮探索性分析为我们带来了一些关键发现：目标变量存在明显的**类别不平衡**，年轻员工和特定部门表现出更高的流失倾向，而 `MaritalStatus` 与 `DistanceFromHome` 的组合揭示了有趣的交互效应，即单身且住得远的员工流失风险显著更高。

我们通过相关性分析和分布对比，识别出了一批与流失强相关的特征。这些发现不只是停留在"**Insight**"层面的业务洞察，它们将直接指导接下来的工作：哪些特征需要重点关注？是否需要分箱处理？要不要构建组合特征来捕捉交互效应？

接下来的**特征工程**阶段，我们将把这些从数据中提炼出的模式转化为模型可以学习的有效输入，让预测不仅准确，也能清晰地解释"为什么会流失"。
